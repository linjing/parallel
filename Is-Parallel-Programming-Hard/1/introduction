而不是抱怨的并行编程的难度，而是探讨为什么并行编程是困难的原因，进而帮助读者克服这些困难

为什么困难
----------

1。历史成本高和并行系统的相对稀缺性。

2。典型的研究者和实践者的缺乏与并行系统的经验。

3。公开访问的并行代码的缺乏。

4。一个广泛的理解工程学科并行编程的缺乏。

5。通信相对的处理开销大，即使在紧耦合共享内存计算机。

好吧，反正比顺序编程难

并行编程的三大目标（和上面的顺序编程）如下：
-------------------------------------------

1。性能。==> 主要目标
  “性能”解释相当广泛，包括可扩展性（每CPU性能）和效率（例如，每瓦性能）。就是说，绩效的重点已转向从硬件并行软件。这个焦点上的变化是由于这样的事实，虽然穆尔的法律继续提供晶体管密度增加，它已经停止提供传统的单线程性能的提高。
  

2。生产力。
  一个在硬件成本的迅速降低的不可避免的后果是，软件生产效率变得越来越重要。只是使硬件高效利用它不再是：现在有必要使非常有效的利用软件开发商以及。这一直是连续的硬件的情况下，但并行的硬件已经成为最近一个低成本的商品。因此，最近的高生产率成为非常重要的并行软件的时候。

3。共性。
  通用性往往是在性能，成本效率为代价

~~ 正确性，可维护性，和鲁棒性 ~~
~~ 可扩展性，特别是考虑到实现线性的可伸缩性的最简单的方法是减少每个CPU性能 ~~

工程权衡性能，生产力，和通用性，或避免冲突

并行编程方案
------------
性能的关键代码在软件堆栈的底部

1 multiple instances (多个实例)
   运行顺序的应用程序的多个实例可以让你做不做并行编程的并行编程。有大量的处理方式，取决于应用程序的结构。它往往是非常高效的，极端的性能提升，获得很少或根本没有额外的努力
2 使应用程序使用现有的并行软件
  cgi 放到 apache 后面
3 应用的性能优化的串行应用
  什么瓶颈 ？？？？

